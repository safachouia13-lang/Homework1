#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//تعريف نوع Node وProduct//
typedef struct Product {
    int ID;
    char Name[20];
    int Price;
} Product;
typedef struct Node {
    Product Prod;
    struct Node *next;
} Node;
//إنشاء قائمة فارغة//
//للإشارة إلى أول عنصر نستخدم المؤشر head//
Node* createEmptyList() {
    return NULL; // head = NULL => قائمة فارغة//
}
//دالة تفحص إن كانت القائمة فارغة//
int isEmpty(Node *head) {
    return (head == NULL);
}
//دالة مساعدة لإنشاء بسرعة Product//
Product makeProduct(int id, const char *name, int price) {
    Product p;
    p.ID = id;
//لتفادي تخطي حدود مصفوفة نستخدم strncpy//
    strncpy(p.Name, name, sizeof(p.Name) - 1);
    p.Name[sizeof(p.Name) - 1] = '\0'; //التأكد من انتهاء النص//
    p.Price = price;
    return p;
}
//إدراج عنصر في بداية القائمة الدائرية//
//نضيف عقدة جديدة ونعدّل روابط النهاية بحيث تشير إلى العنصر الجديد كبداية//
Node* insertAtBeginning(Node *head, Product p) {
//تخصيص عقدة جديدة//
    Node *n = (Node*) malloc(sizeof(Node));
    if (n == NULL) { //تحقق من نجاح التخصيص//
        printf("Memory allocation failed\n");
        exit(1);
    }
    n->Prod = p;// نسخ بيانات المنتج في العقدة الجديدة//
    if (head == NULL) {
    //القائمة كانت فارغة -> العقدة الجديدة تشير لنفسها//
        n->next = n;
        return n;// العقدة الجديدة تصبح head//
    }

    //القائمة غير فارغة//
    //يجب إيجاد آخر عنصر في القائمة (الذي يشير إلى head)//
    Node *last = head;
    while (last->next != head) { //نحرك آخر حتى نصل للعقدة التي تشير للبداية//
        last = last->next;
    }
    n->next = head;// الجديد يشير للبداية القديمة//
    last->next = n;// آخر الآن يشير للجديد (الذي صار بداية)//
    return n;// نعيد n كـ head الجديد//
}
//إدراج عنصر في نهاية القائمة الدائرية//
Node* insertAtEnd(Node *head, Product p) {
    // تخصيص عقدة جديدة//
    Node *n = (Node*) malloc(sizeof(Node));
    if (n == NULL) {
        printf("Memory allocation failed\n");
        exit(1);
    }
    n->Prod = p;
    if (head == NULL) {
    //إذا كانت القائمة فارغة، العقدة تشير لنفسها وتصبح head//
        n->next = n;
        return n;
    }
    //إيجاد آخر عنصر (الذي يشير إلى head)//
    Node *last = head;
    while (last->next != head) {
        last = last->next;
    }
    // إدراج العقدة الجديدة بعد الأخير، والحفاظ على الحلقة//
    last->next = n;
    n->next = head;
    return head; // head لا يتغير عند الإدراج في النهاية//
}
//عرض العناصر مرة واحدة فقط بدون حلقة لانهائية)//
//نستخدم do-while لنتأكد أن العنصر الأول يُطبع أيضًا قبل التوقف//
void displayList(Node *head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }
    Node *temp = head;
    printf("Products in the circular list:\n");
    do {
        printf("ID: %d | Name: %s | Price: %d\n",
               temp->Prod.ID, temp->Prod.Name, temp->Prod.Price);
        temp = temp->next;
    } while (temp != head); // نتوقف عندما نعود إلى البداية//
}
//تحرير كل الذاكرة المستخدمة//
void freeList(Node *head) {
    if (head == NULL) return;
    Node *cur = head->next;
    Node *nextNode;
    while (cur != head) {
        nextNode = cur->next;
        free(cur);
        cur = nextNode;
    }
    free(head); // نحرر العقدة الأولى أيضاً//
}
int main() {
    Node *head = createEmptyList();  // نبدأ بقائمة فارغة//
    head = insertAtBeginning(head, makeProduct(1, "Milk", 50));// إدراج في البداية//
    head = insertAtEnd(head, makeProduct(2, "Bread", 30));// إدراج في النهاية//
    head = insertAtBeginning(head, makeProduct(3, "Sugar", 80));// إدراج في البداية//
    head = insertAtEnd(head, makeProduct(4, "Eggs", 120));// إدراج في النهاية//
    displayList(head); // عرض الكل مرة واحدة//
    freeList(head);//تحرير الذاكرة//
    return 0;
}
